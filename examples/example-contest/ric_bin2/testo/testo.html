<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>testo</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <style type="text/css">
body {
font-family: Helvetica, arial, sans-serif;
font-size: 14px;
line-height: 1.6;
padding-top: 10px;
padding-bottom: 10px;
background-color: white;
padding: 30px;
color: #333;
}
body > *:first-child {
margin-top: 0 !important;
}
body > *:last-child {
margin-bottom: 0 !important;
}
a {
color: #4183C4;
text-decoration: none;
}
a.absent {
color: #cc0000;
}
a.anchor {
display: block;
padding-left: 30px;
margin-left: -30px;
cursor: pointer;
position: absolute;
top: 0;
left: 0;
bottom: 0;
}
table {
padding: 0;
border-collapse:collapse;
}
h1, h2, h3, h4, h5, h6 {
margin: 20px 0 10px;
padding: 0;
font-weight: bold;
-webkit-font-smoothing: antialiased;
cursor: text;
position: relative;
}
h2:first-child, h1:first-child, h1:first-child + h2, h3:first-child, h4:first-child, h5:first-child, h6:first-child {
margin-top: 0;
padding-top: 0;
}
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
text-decoration: none;
}
h1 tt, h1 code {
font-size: inherit;
}
h2 tt, h2 code {
font-size: inherit;
}
h3 tt, h3 code {
font-size: inherit;
}
h4 tt, h4 code {
font-size: inherit;
}
h5 tt, h5 code {
font-size: inherit;
}
h6 tt, h6 code {
font-size: inherit;
}
h1 {
font-size: 28px;
color: black;
}
h2 {
font-size: 24px;
border-bottom: 1px solid #cccccc;
color: black;
}
h3 {
font-size: 18px;
}
h4 {
font-size: 16px;
}
h5 {
font-size: 14px;
}
h6 {
color: #777777;
font-size: 14px;
}
p, blockquote, ul, ol, dl, li, table, pre {
margin: 15px 0;
}
hr {
border: 0 none;
color: #cccccc;
height: 4px;
padding: 0;
}
body > h2:first-child {
margin-top: 0;
padding-top: 0;
}
body > h1:first-child {
margin-top: 0;
padding-top: 0;
}
body > h1:first-child + h2 {
margin-top: 0;
padding-top: 0;
}
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
margin-top: 0;
padding-top: 0;
}
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
margin-top: 0;
padding-top: 0;
}
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
margin-top: 0;
}
li p.first {
display: inline-block;
}
ul, ol {
padding-left: 30px;
}
ul :first-child, ol :first-child {
margin-top: 0;
}
ul :last-child, ol :last-child {
margin-bottom: 0;
}
dl {
padding: 0;
}
dl dt {
font-size: 14px;
font-weight: bold;
font-style: italic;
padding: 0;
margin: 15px 0 5px;
}
dl dt:first-child {
padding: 0;
}
dl dt > :first-child {
margin-top: 0;
}
dl dt > :last-child {
margin-bottom: 0;
}
dl dd {
margin: 0 0 15px;
padding: 0 15px;
}
dl dd > :first-child {
margin-top: 0;
}
dl dd > :last-child {
margin-bottom: 0;
}
blockquote {
border-left: 4px solid #dddddd;
padding: 0 15px;
color: #777777;
}
blockquote > :first-child {
margin-top: 0;
}
blockquote > :last-child {
margin-bottom: 0;
}
table {
padding: 0;
}
table tr {
border-top: 1px solid #cccccc;
background-color: white;
margin: 0;
padding: 0;
}
table tr:nth-child(2n) {
background-color: #f8f8f8;
}
table tr th {
font-weight: bold;
border: 1px solid #cccccc;
text-align: left;
margin: 0;
padding: 6px 13px;
}
table tr td {
border: 1px solid #cccccc;
text-align: left;
margin: 0;
padding: 6px 13px;
}
table tr th :first-child, table tr td :first-child {
margin-top: 0;
}
table tr th :last-child, table tr td :last-child {
margin-bottom: 0;
}
img {
max-width: 100%;
}
span.frame {
display: block;
overflow: hidden;
}
span.frame > span {
border: 1px solid #dddddd;
display: block;
float: left;
overflow: hidden;
margin: 13px 0 0;
padding: 7px;
width: auto;
}
span.frame span img {
display: block;
float: left;
}
span.frame span span {
clear: both;
color: #333333;
display: block;
padding: 5px 0 0;
}
span.align-center {
display: block;
overflow: hidden;
clear: both;
}
span.align-center > span {
display: block;
overflow: hidden;
margin: 13px auto 0;
text-align: center;
}
span.align-center span img {
margin: 0 auto;
text-align: center;
}
span.align-right {
display: block;
overflow: hidden;
clear: both;
}
span.align-right > span {
display: block;
overflow: hidden;
margin: 13px 0 0;
text-align: right;
}
span.align-right span img {
margin: 0;
text-align: right;
}
span.float-left {
display: block;
margin-right: 13px;
overflow: hidden;
float: left;
}
span.float-left span {
margin: 13px 0 0;
}
span.float-right {
display: block;
margin-left: 13px;
overflow: hidden;
float: right;
}
span.float-right > span {
display: block;
overflow: hidden;
margin: 13px auto 0;
text-align: right;
}
code, tt {
margin: 0 2px;
padding: 0 5px;
white-space: nowrap;
border: 1px solid #eaeaea;
background-color: #f8f8f8;
border-radius: 3px;
}
pre code {
margin: 0;
padding: 0;
white-space: pre;
border: none;
background: transparent;
}
.highlight pre {
background-color: #f8f8f8;
border: 1px solid #cccccc;
font-size: 13px;
line-height: 19px;
overflow: auto;
padding: 6px 10px;
border-radius: 3px;
}
pre {
background-color: #f8f8f8;
border: 1px solid #cccccc;
font-size: 13px;
line-height: 19px;
overflow: auto;
padding: 6px 10px;
border-radius: 3px;
}
pre code, pre tt {
background-color: transparent;
border: none;
}
</style>
</head>
<body>
<h1 id="ricerca-binaria-approfondimenti-ric_bin2">Ricerca binaria: approfondimenti (ric_bin2)</h1>
<h2 id="descrizione-del-problema">Descrizione del problema</h2>
<p>Questo problema ha i seguenti obiettivi:</p>
<ul>
<li><p>sbloccare chi di voi sia rimasto in sospeso con l’esercizio <code>ric_bin</code> proposto precedentemente, in particore chiedendo di concentrarti sulla determinazione del minimo numero di chiamate alla funzione guess che sarà sempre sufficiente ad indovinare il numero incognito.</p></li>
<li><p>introdurre alla programmazione dinamica e incoraggiare all’approccio ricorsivo nella soluzione dei problemi.</p></li>
</ul>
<p>Nel problema <code>ric_bin</code> eri chiamato a determinare un numero naturale nell’intervallo <span class="math inline">[1, <em>n</em>]</span>. Per determinarlo potevi chiamare una funzione <code>confronto_con(g)</code> la quale, assumendo che g sia la vostra proposta e <span class="math inline"><em>x</em></span> il numero incognito da determinarsi, specificava quale dei seguenti tre fosse il caso: + <span class="math inline"><em>g</em> &gt; <em>x</em></span> + <span class="math inline"><em>g</em> &lt; <em>x</em></span> + <span class="math inline"><em>g</em> = <em>x</em></span></p>
<p>Una singola partita a questo gioco può essere vista come una sequenza di domande e risposte. L’obiettivo del giocatore è minimizzare il numero delle domande utilizzate per ottenere certezza sul valore di <span class="math inline"><em>x</em></span>. Tuttavia, anche giocando secondo uno schema deterministico prefissato a priori (ad esempio, qualora <span class="math inline"><em>n</em></span> fosse <span class="math inline">3</span>, allora stabilisco che la prima chiamata a <code>confronto_con(g)</code> avverrà sempre con <span class="math inline"><em>g</em> = 2</span>), è chiaro che il numero delle chiamate possa dipendere dal valore di <span class="math inline"><em>x</em></span>, che potrebbe quindi venire scelto dall’avversario per mettermii in difficoltà.</p>
<p>Ti chiediamo di progettare una strategia che minimizzi il numero delle chiamate a <code>confronto_con(g)</code> sul più bastardo degli <span class="math inline"><em>x</em></span> scelto poi dall’avversario.</p>
<p>Quando ti sarai fatto chiarezza su come possa essere fatta una tale strategia (a seconda del valore di <span class="math inline"><em>n</em></span> non è detto sia unica) dovrai scrivere un programma che, dato in input un numero intero positivo <span class="math inline"><em>n</em></span>, ritorni il più piccolo numero f(n) tale che esista una strategia <span class="math inline"><em>S</em>(<em>n</em>)</span> che garantisca quanto segue: qualsiasi sia il valore del numero incognito <span class="math inline"><em>x</em></span>, con <span class="math inline">1 ≤ <em>x</em> ≤ <em>n</em></span>, allora, applicando la strategia <span class="math inline"><em>S</em>(<em>n</em>)</span>, stabilirai il valore di <span class="math inline"><em>x</em></span> in al più <span class="math inline"><em>f</em>(<em>n</em>)</span> domande.</p>
<p>Si noti che una strategia <span class="math inline"><em>S</em>(<em>n</em>)</span> può essere vista come un albero la cui radice esprime la situazione del gioco prima di aver fatto la prima domanda (la prima chiamata a <code>confronto_con(g)</code>) e le foglie corrispondono alle situazioni in cui il valore di <span class="math inline"><em>x</em></span> è infine determinato. Di fatto le foglie saranno precisamente <span class="math inline"><em>n</em></span>, una per ciascuno dei possibili valori di x. Ogni nodo dell’albero <span class="math inline"><em>S</em>(<em>n</em>)</span> che non sia una foglia (ossia dove il valore di <span class="math inline"><em>x</em></span> non sia stato ancora determinato con certezza) specifica quale sia la domanda che conviene fare (una delle domande ottime, in certi casi potrebbero essere più di una) in quella situazione. I figli di tale nodo non-foglia saranno al massimo <span class="math inline">3</span>, e corrisponderanno sempre alle possibili risposte da parte di <code>confronto_con(g)</code>.</p>
<p>In pratica, quando risolvi questo problema stai implicitamente progettando un tale albero che abbia altezza minima (altezza di un albero è la più lunga distanza di una foglia dalla radice).</p>
<p>Chi vuole risolvere un problema come questo, non disdegna affrontare prima i casi più piccoli:</p>
<table>
<thead>
<tr class="header">
<th>n</th>
<th>f(n)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>2</td>
<td>1</td>
</tr>
<tr class="even">
<td>3</td>
<td>?</td>
</tr>
</tbody>
</table>
<p>Sei invitato a proseguire nella compilazione di questa tabella.</p>
<p><em>Nota 1:</em> Sul CMS vi è data la possibilità di fornire voi le istanze sulle quali volete che la vostra sottomissione venga valutata. Questo può consentirvi di risolvere dei vostri dubbi in modo autonomo. Ad esempio quì, se volete ottenere conferma sul valore corretto di <span class="math inline"><em>f</em>(3)</span> e/o dei successivi, potete sottomettere quella specifica istanza e testare su di essa il vostro algoritmo (o magari un algoritmo più stupido e sicuro che si limiti a stampare la risposta che reputate corretta per quell’istanza).</p>
<p><em>Nota 2:</em> Per altro non vi è vietato, anzi siete incoraggiati, a scambiarvi idee ed aiuto tra di voi, e/o a chiedere a noi (sia sul Gruppo Telegram che privatamente, come reputate più opportuno). Questo perchè non vorrei fraintendeste il vero messaggio della nota sopra, che mira solo a fornirvi uno strumento in più per gestirvi in ogni situazione e magari anche per andare a scoprire e segnalarci eventuali errori nei nostri materiali, codici, e problemi.</p>
<h2 id="due-metodologie-che-se-le-portate-davvero-a-casa-cè-di-che-essere-soddisfatti-sullesito-complessivo-di-tutto-il-corso">Due metodologie che se le portate davvero a casa c’è di che essere soddisfatti sull’esito complessivo di tutto il corso</h2>
<p>Torniamo al suggerimento di cominciare provando a stabilire uno per uno i valori nella tabella, partendo dai più piccoli (approccio bottom-up). E’ un suggerimento davvero molto importante. Un approccio che dovete fare vostro in questo corso dove miriamo a fare di voi dei problem solvers.</p>
<p>Approccio ricorsivo significa proprio questo: che ad un certo punto cerchi di trovare un modo semplice di mettere in relazione i valori di queste righe, riducendo il problema del computo di <span class="math inline"><em>f</em>(<em>n</em>)</span> per una certa riga (per un certo <span class="math inline"><em>n</em></span>) alla stessa questione già risolta per righe più piccole. Questo è il grimaldello universale per la soluzione dei problemi nella Concrete Mathematics, ossia in quel ramo della matematica che offre gli sturmenti concettuali ed algoritmici portanti per l’informatica.</p>
<p>La ricorsione viene spesso associata all’approccio visto in rovesciato (approccio top-down), in quanto l’idea è poi quella di trovare il modo di decomporre il problema del computo di <span class="math inline"><em>f</em>(<em>n</em>)</span> in problemi più piccoli dello stesso tipo (ossia ricompresi nello stesso linguaggio, ossia domande del titpo <span class="math inline"><em>f</em>(<em>n</em>′)</span> ma con <span class="math inline"><em>n</em>′ &lt; <em>n</em></span>).</p>
<p>Distinguiamo tra due piani: la comprensione della struttura del problema che conduce alla sua soluzione (scoperta del nesso ricorsivo, la chiave d’oro che apre il problema e lo spacca), e come poi questa comprensione strutturale vada sfruttata coniugata in un algoritmo (un metodo generale per la soluzione di quel problema), che in in linea di massima è già un momento successivo che spesso risulta cruciale saper ben separare. (Il momento del progetto dell’implementazione è poi un ulteriore stadio, non stò parlando di questa seconda distinzione anche cruciale ma già secondaria a quella che intendo rimarcare ora.)</p>
<p>Quando per rispondere alla domanda per una certa riga tu dovessi interrogare le risposte per più righe, un algoritmo di tipo ricorsivo (top down) risulterebbe subito inefficiente quando per rispondere ad ogni singola chiamata ne venissero attivate diverse. Ma nessuno ti vieta di lavorare direttamente su una tale tabella (tabella di programmazione dinamica) entro il tuo algoritmo, determinando i valori riga per riga, una riga alla volta. Questo può farti passare da un algoritmo ricorsivo che richiede tempo esponenziale (farebbe un numero esponenziale di chiamate) ad un algoritmo che effettua solo un numero lineare di chiamate nella magnitudo di <span class="math inline"><em>n</em></span> (ossia se <span class="math inline"><em>n</em> = 100</span> fa al più <span class="math inline"><em>O</em>(<em>n</em>)</span> chiamate), ossia che và molto veloce e funziona anche in pratica per valori già interessanti di <span class="math inline"><em>n</em></span>. (Se la scrittura <span class="math inline"><em>O</em>(<em>n</em>)</span> ti è arabo devi andare a riguardarti l’uso della notazione asintotica. Per noi algoritmisti è uno degli strumenti base di lavoro.)</p>
<p>E se volessimo poi un algoritmo che gira in tempo polilogaritmico nella magnitudo di <span class="math inline"><em>n</em></span>, ossia polinomiale nella lunghezza della codifica binaria (ossia a bits) di <span class="math inline"><em>n</em></span>? Riesci poi a produrre anche questo?</p>
<h2 id="esempi">Esempi</h2>
<p>Dalle risposte già riportate nella tabella sopra:</p>
<table>
<thead>
<tr class="header">
<th>input from stdin</th>
<th>output to stdout</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>input from stdin</th>
<th>output to stdout</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
<h2 id="subtask">Subtask</h2>
<ul>
<li><strong>Subtask 1 [10 punti]</strong>: <span class="math inline"><em>n</em> ≤ 5</span>.</li>
<li><strong>Subtask 2 [10 punti]</strong>: <span class="math inline"><em>n</em> ≤ 10</span>.</li>
<li><strong>Subtask 3 [20 punti]</strong>: <span class="math inline"><em>n</em> ≤ 100</span>.</li>
<li><strong>Subtask 12 [20 punti]</strong>: <span class="math inline"><em>n</em> ≤ 1000</span>.</li>
<li><strong>Subtask 12 [20 punti]</strong>: <span class="math inline"><em>n</em> ≤ 1 000 000</span>.</li>
<li><strong>Subtask 13 [20 punti]</strong>: <span class="math inline"><em>n</em> ≤ 100 000 000 000</span>.</li>
</ul>
</body>
</html>
